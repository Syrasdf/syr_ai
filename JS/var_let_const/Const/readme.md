# js历史

- const 
  常量，es5没有专门的常量声明
  
  1.简单数据类型，值不能改变
  String Number Boolean Null Undefined

  2.复杂数据类型（对象），值可以改变，指向的内存地址不能改。（引用式赋值）
  Object Array Function
  <!-- 没有块级作用域，没有变量提升，不能重复声明，不能修改值 -->
  
  - 赋值
    如果是简单数据类型 值传递 直接赋值
    如果是复杂数据类型 引用传递 把地址赋值给变量 （引用式赋值）
    引用传递 地址指向的内存地址不能改，但是值可以改。
    const 类型不同 处理不同
    
    内存的储存分为
    内存栈 连续 空间小 快
    内存堆 不连续 空间大 慢
    const 在简单数据类型，复杂数据类型虽然表现不一致，<内存栈中的值不会发生改变>（两者一样的原因）

   es6 第一个新特性 let const ，弥补了es5只有var的不足，支持块级作用域，支持常量 
   es5 js用来设计页面交互，简单， 

   那么为什么要引入es6呢？
   es6 目标是让JS 成为企业级别的大型应用开发语言，拥抱其他语义开发者 ，和JAVA，C++ 等语言一样，

   - TDZ 解决了变量提升的 代码阅读和执行歧义（可读性） 问题
   - 块级作用域 
     大型语言的需要
     for 等......
   - 变量，常量的内存分配
     内存栈  js  执行上下文分配内存的主战场 
     连续，快
     内存堆 不连续的，慢 

   - 简单数据类型，const 不能修改值，
     复杂数据类型，const 引用的地址不能修改，但是可以修改值。
     （const 类型不同 处理不同）
     值传递
     引用式赋值
     
   - var 在前端声明的变量会挂在window上，
     而let const 不会挂在window上，
     所以在开发中，尽量使用let const 来声明变量，
     避免变量污染


堆与栈的普及
栈：
1.栈是一种线性结构，先进后出
2.栈内存的大小是固定的，由系统分配（硬盘，速度慢）
举例解释说明
在堆里为什么能修改

//复杂数据类型栈中存的是地址，地址指向堆中的数据，所以改变了
Js是动态的,对象可能会变化，所以对象的地址是不变的，但是对象中的属性是可以改变的
